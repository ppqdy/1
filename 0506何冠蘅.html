<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二次函数图像生成器</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #8a2be2, #4169e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .control-section {
            flex: 1;
            min-width: 300px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(65, 105, 225, 0.2);
            cursor: pointer;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        .panel-control {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .panel-control:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .panel-content {
            padding: 20px;
            transition: all 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }
        
        .panel-minimized .panel-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .graph-container {
            flex: 2;
            min-width: 500px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            position: relative;
            border: 1px solid rgba(138, 43, 226, 0.2);
        }
        
        canvas {
            background: white;
            border-radius: 10px;
            width: 100%;
            height: 500px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #b19cd9;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            transition: all 0.3s;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        
        input[type="number"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.5);
            border-color: #8a2be2;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8a2be2;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #9b4de3;
            transform: scale(1.1);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #8a2be2, #4169e1);
            color: white;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .reset-button {
            background: linear-gradient(to right, #e2407e, #8a2be2) !important;
        }
        
        .info-panel {
            margin-top: 25px;
            padding: 15px;
            background: rgba(65, 105, 225, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(138, 43, 226, 0.2);
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
            color: #b19cd9;
        }
        
        .info-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .info-value {
            font-weight: 600;
            color: #8a2be2;
        }
        
        .function-display {
            text-align: center;
            font-size: 1.5rem;
            margin: 15px 0;
            padding: 10px;
            background: rgba(65, 105, 225, 0.1);
            border-radius: 8px;
            font-family: 'Cambria Math', serif;
            border: 1px solid rgba(138, 43, 226, 0.2);
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(65, 105, 225, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(138, 43, 226, 0.2);
        }
        
        .toggle-label {
            flex: 1;
            font-weight: 600;
            color: #b19cd9;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.1);
            transition: .4s;
            border-radius: 30px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #8a2be2;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .graph-container {
                min-width: 100%;
            }
            
            .control-section {
                min-width: 100%;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
        
        .save-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(65, 105, 225, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .save-notification.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>二次函数图像生成器</h1>
            <p class="subtitle">探索二次函数 y = ax² + bx + c 的图像与性质</p>
        </header>
        
        <div class="content">
            <div class="control-section">
                <div class="panel-header" id="controlPanelHeader">
                    <div class="panel-title">函数控制面板</div>
                    <div class="panel-control" id="controlMinimizeBtn">−</div>
                </div>
                <div class="panel-content" id="controlPanelContent">
                    <div class="function-display" id="functionDisplay">
                        y = <span id="aValue">1</span>x² + <span id="bValue">0</span>x + <span id="cValue">0</span>
                    </div>
                    
                    <div class="toggle-group">
                        <div class="toggle-label">整数模式</div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="integerMode">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="input-group">
                        <label for="a">a 值 (二次项系数)</label>
                        <div class="slider-container">
                            <input type="range" id="aSlider" min="-5" max="5" step="0.1" value="1">
                            <input type="number" id="aInput" min="-5" max="5" step="0.1" value="1">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="b">b 值 (一次项系数)</label>
                        <div class="slider-container">
                            <input type="range" id="bSlider" min="-10" max="10" step="0.1" value="0">
                            <input type="number" id="bInput" min="-10" max="10" step="0.1" value="0">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="c">c 值 (常数项)</label>
                        <div class="slider-container">
                            <input type="range" id="cSlider" min="-10" max="10" step="0.1" value="0">
                            <input type="number" id="cInput" min="-10" max="10" step="0.1" value="0">
                        </div>
                    </div>
                    
                    <div class="button-group">
                        <button id="resetView">重置视图</button>
                        <button id="randomFunction">随机函数</button>
                        <button id="saveImage">保存图片</button>
                        <button id="resetFunction" class="reset-button">重置函数</button>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="panel-header" id="propertyPanelHeader">
                    <div class="panel-title">函数性质</div>
                    <div class="panel-control" id="propertyMinimizeBtn">−</div>
                </div>
                <div class="panel-content" id="propertyPanelContent">
                    <div class="info-panel">
                        <h3>函数性质</h3>
                        <div class="info-item">
                            <span>开口方向:</span>
                            <span class="info-value" id="openingDirection">向上</span>
                        </div>
                        <div class="info-item">
                            <span>顶点:</span>
                            <span class="info-value" id="vertex">(0, 0)</span>
                        </div>
                        <div class="info-item">
                            <span>对称轴:</span>
                            <span class="info-value" id="axis">x = 0</span>
                        </div>
                        <div class="info-item">
                            <span>判别式 Δ:</span>
                            <span class="info-value" id="discriminant">0</span>
                        </div>
                        <div class="info-item">
                            <span>与x轴交点:</span>
                            <span class="info-value" id="xIntercepts">(0, 0)</span>
                        </div>
                        <div class="info-item">
                            <span>与y轴交点:</span>
                            <span class="info-value" id="yIntercept">(0, 0)</span>
                        </div>
                        <div class="info-item">
                            <span>函数值域:</span>
                            <span class="info-value" id="range">[0, +∞)</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="graph-container">
                <canvas id="graphCanvas" width="800" height="500"></canvas>
            </div>
        </div>
    </div>
    
    <div class="save-notification" id="saveNotification">图片已保存！</div>

    <script>
        // 获取DOM元素
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // 获取输入元素
        const aSlider = document.getElementById('aSlider');
        const aInput = document.getElementById('aInput');
        const bSlider = document.getElementById('bSlider');
        const bInput = document.getElementById('bInput');
        const cSlider = document.getElementById('cSlider');
        const cInput = document.getElementById('cInput');
        const integerMode = document.getElementById('integerMode');
        
        // 获取显示元素
        const aValue = document.getElementById('aValue');
        const bValue = document.getElementById('bValue');
        const cValue = document.getElementById('cValue');
        const functionDisplay = document.getElementById('functionDisplay');
        
        // 获取信息面板元素
        const openingDirection = document.getElementById('openingDirection');
        const vertex = document.getElementById('vertex');
        const axis = document.getElementById('axis');
        const discriminant = document.getElementById('discriminant');
        const xIntercepts = document.getElementById('xIntercepts');
        const yIntercept = document.getElementById('yIntercept');
        const range = document.getElementById('range');
        
        // 获取按钮元素
        const resetViewBtn = document.getElementById('resetView');
        const randomFunctionBtn = document.getElementById('randomFunction');
        const saveImageBtn = document.getElementById('saveImage');
        const resetFunctionBtn = document.getElementById('resetFunction');
        
        // 面板控制元素
        const controlPanel = document.querySelector('.control-section:first-child');
        const controlPanelHeader = document.getElementById('controlPanelHeader');
        const controlPanelContent = document.getElementById('controlPanelContent');
        const controlMinimizeBtn = document.getElementById('controlMinimizeBtn');
        
        const propertyPanel = document.querySelector('.control-section:nth-child(2)');
        const propertyPanelHeader = document.getElementById('propertyPanelHeader');
        const propertyPanelContent = document.getElementById('propertyPanelContent');
        const propertyMinimizeBtn = document.getElementById('propertyMinimizeBtn');
        
        const saveNotification = document.getElementById('saveNotification');
        
        // 图形参数
        let scale = 40; // 缩放比例
        let offsetX = canvas.width / 2; // X轴偏移
        let offsetY = canvas.height / 2; // Y轴偏移
        let isDragging = false;
        let lastX, lastY;
        
        // 初始化
        function init() {
            // 设置事件监听器
            aSlider.addEventListener('input', updateA);
            aInput.addEventListener('input', updateA);
            bSlider.addEventListener('input', updateB);
            bInput.addEventListener('input', updateB);
            cSlider.addEventListener('input', updateC);
            cInput.addEventListener('input', updateC);
            integerMode.addEventListener('change', toggleIntegerMode);
            
            resetViewBtn.addEventListener('click', resetView);
            randomFunctionBtn.addEventListener('click', generateRandomFunction);
            saveImageBtn.addEventListener('click', saveImage);
            resetFunctionBtn.addEventListener('click', resetFunction);
            
            // 面板控制事件
            controlPanelHeader.addEventListener('click', () => toggleMinimize(controlPanel, controlMinimizeBtn));
            propertyPanelHeader.addEventListener('click', () => toggleMinimize(propertyPanel, propertyMinimizeBtn));
            
            // 添加鼠标事件用于平移
            canvas.addEventListener('mousedown', startDrag);
            canvas.addEventListener('mousemove', drag);
            canvas.addEventListener('mouseup', endDrag);
            canvas.addEventListener('mouseleave', endDrag);
            
            // 添加触摸事件
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // 添加滚轮缩放
            canvas.addEventListener('wheel', handleWheel);
            
            // 初始绘制
            updateFunction();
            drawGraph();
        }
        
        // 切换整数模式
        function toggleIntegerMode() {
            if (integerMode.checked) {
                // 切换到整数模式
                aSlider.step = "1";
                aInput.step = "1";
                bSlider.step = "1";
                bInput.step = "1";
                cSlider.step = "1";
                cInput.step = "1";
                
                // 将当前值四舍五入为整数
                aSlider.value = Math.round(aSlider.value);
                aInput.value = Math.round(aInput.value);
                bSlider.value = Math.round(bSlider.value);
                bInput.value = Math.round(bInput.value);
                cSlider.value = Math.round(cSlider.value);
                cInput.value = Math.round(cInput.value);
            } else {
                // 切换到小数模式
                aSlider.step = "0.1";
                aInput.step = "0.1";
                bSlider.step = "0.1";
                bInput.step = "0.1";
                cSlider.step = "0.1";
                cInput.step = "0.1";
            }
            
            updateFunction();
            drawGraph();
        }
        
        // 更新a值
        function updateA() {
            let value = parseFloat(aSlider.value);
            
            // 如果是整数模式，将值四舍五入为整数
            if (integerMode.checked) {
                value = Math.round(value);
            }
            
            aSlider.value = value;
            aInput.value = value;
            aValue.textContent = formatCoefficient(value);
            updateFunction();
            drawGraph();
        }
        
        // 更新b值
        function updateB() {
            let value = parseFloat(bSlider.value);
            
            // 如果是整数模式，将值四舍五入为整数
            if (integerMode.checked) {
                value = Math.round(value);
            }
            
            bSlider.value = value;
            bInput.value = value;
            bValue.textContent = formatCoefficient(value);
            updateFunction();
            drawGraph();
        }
        
        // 更新c值
        function updateC() {
            let value = parseFloat(cSlider.value);
            
            // 如果是整数模式，将值四舍五入为整数
            if (integerMode.checked) {
                value = Math.round(value);
            }
            
            cSlider.value = value;
            cInput.value = value;
            cValue.textContent = formatCoefficient(value);
            updateFunction();
            drawGraph();
        }
        
        // 格式化系数显示
        function formatCoefficient(value) {
            if (value === 0) return '0';
            if (value === 1) return '';
            if (value === -1) return '-';
            return value.toString();
        }
        
        // 更新函数信息
        function updateFunction() {
            const a = parseFloat(aInput.value);
            const b = parseFloat(bInput.value);
            const c = parseFloat(cInput.value);
            
            // 更新函数显示
            let functionText = 'y = ';
            functionText += a === 1 ? 'x²' : a === -1 ? '-x²' : a + 'x²';
            
            if (b !== 0) {
                functionText += b > 0 ? ' + ' : ' - ';
                functionText += b === 1 || b === -1 ? 'x' : Math.abs(b) + 'x';
            }
            
            if (c !== 0) {
                functionText += c > 0 ? ' + ' : ' - ';
                functionText += Math.abs(c);
            }
            
            functionDisplay.textContent = functionText;
            
            // 计算函数性质
            const vertexX = -b / (2 * a);
            const vertexY = a * vertexX * vertexX + b * vertexX + c;
            
            // 更新信息面板
            openingDirection.textContent = a > 0 ? '向上' : '向下';
            vertex.textContent = `(${vertexX.toFixed(2)}, ${vertexY.toFixed(2)})`;
            axis.textContent = `x = ${vertexX.toFixed(2)}`;
            
            const disc = b * b - 4 * a * c;
            discriminant.textContent = disc.toFixed(2);
            
            if (disc > 0) {
                const x1 = (-b + Math.sqrt(disc)) / (2 * a);
                const x2 = (-b - Math.sqrt(disc)) / (2 * a);
                xIntercepts.textContent = `(${x1.toFixed(2)}, 0), (${x2.toFixed(2)}, 0)`;
            } else if (disc === 0) {
                const x = -b / (2 * a);
                xIntercepts.textContent = `(${x.toFixed(2)}, 0)`;
            } else {
                xIntercepts.textContent = '无实数解';
            }
            
            // 与y轴交点
            yIntercept.textContent = `(0, ${c.toFixed(2)})`;
            
            // 函数值域
            if (a > 0) {
                range.textContent = `[${vertexY.toFixed(2)}, +∞)`;
            } else {
                range.textContent = `(-∞, ${vertexY.toFixed(2)}]`;
            }
        }
        
        // 绘制图形
        function drawGraph() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制坐标轴
            drawAxes();
            
            // 绘制网格
            drawGrid();
            
            // 绘制函数图像
            drawFunction();
            
            // 绘制关键点
            drawKeyPoints();
        }
        
        // 绘制坐标轴
        function drawAxes() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X轴
            ctx.beginPath();
            ctx.moveTo(0, offsetY);
            ctx.lineTo(canvas.width, offsetY);
            ctx.stroke();
            
            // Y轴
            ctx.beginPath();
            ctx.moveTo(offsetX, 0);
            ctx.lineTo(offsetX, canvas.height);
            ctx.stroke();
            
            // 绘制刻度
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // X轴刻度
            for (let x = offsetX % scale; x < canvas.width; x += scale) {
                const value = (x - offsetX) / scale;
                if (Math.abs(value) > 0.1) { // 避免在原点标注
                    ctx.beginPath();
                    ctx.moveTo(x, offsetY - 5);
                    ctx.lineTo(x, offsetY + 5);
                    ctx.stroke();
                    ctx.fillText(value.toFixed(0), x, offsetY + 8);
                }
            }
            
            // Y轴刻度
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = offsetY % scale; y < canvas.height; y += scale) {
                const value = (offsetY - y) / scale;
                if (Math.abs(value) > 0.1) { // 避免在原点标注
                    ctx.beginPath();
                    ctx.moveTo(offsetX - 5, y);
                    ctx.lineTo(offsetX + 5, y);
                    ctx.stroke();
                    ctx.fillText(value.toFixed(0), offsetX - 8, y);
                }
            }
            
            // 标注原点
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText('O', offsetX - 5, offsetY + 5);
            
            // 标注X轴和Y轴
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Y', offsetX - 5, 15);
            ctx.textAlign = 'left';
            ctx.fillText('X', canvas.width - 15, offsetY - 5);
        }
        
        // 绘制网格
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // 垂直线
            for (let x = offsetX % scale; x < canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 水平线
            for (let y = offsetY % scale; y < canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // 绘制函数图像
        function drawFunction() {
            const a = parseFloat(aInput.value);
            const b = parseFloat(bInput.value);
            const c = parseFloat(cInput.value);
            
            ctx.strokeStyle = '#8a2be2';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let isFirstPoint = true;
            
            for (let pixelX = 0; pixelX < canvas.width; pixelX++) {
                const x = (pixelX - offsetX) / scale;
                const y = a * x * x + b * x + c;
                const pixelY = offsetY - y * scale;
                
                if (isFirstPoint) {
                    ctx.moveTo(pixelX, pixelY);
                    isFirstPoint = false;
                } else {
                    ctx.lineTo(pixelX, pixelY);
                }
            }
            
            ctx.stroke();
        }
        
        // 绘制关键点
        function drawKeyPoints() {
            const a = parseFloat(aInput.value);
            const b = parseFloat(bInput.value);
            const c = parseFloat(cInput.value);
            
            // 顶点
            const vertexX = -b / (2 * a);
            const vertexY = a * vertexX * vertexX + b * vertexX + c;
            const vertexPixelX = offsetX + vertexX * scale;
            const vertexPixelY = offsetY - vertexY * scale;
            
            ctx.fillStyle = '#4169e1';
            ctx.beginPath();
            ctx.arc(vertexPixelX, vertexPixelY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // 与x轴交点
            const disc = b * b - 4 * a * c;
            if (disc >= 0) {
                const x1 = (-b + Math.sqrt(disc)) / (2 * a);
                const x2 = (-b - Math.sqrt(disc)) / (2 * a);
                
                ctx.fillStyle = '#8a2be2';
                
                if (!isNaN(x1)) {
                    const x1PixelX = offsetX + x1 * scale;
                    const x1PixelY = offsetY;
                    ctx.beginPath();
                    ctx.arc(x1PixelX, x1PixelY, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (!isNaN(x2) && x1 !== x2) {
                    const x2PixelX = offsetX + x2 * scale;
                    const x2PixelY = offsetY;
                    ctx.beginPath();
                    ctx.arc(x2PixelX, x2PixelY, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 与y轴交点
            const yInterceptPixelX = offsetX;
            const yInterceptPixelY = offsetY - c * scale;
            
            ctx.fillStyle = '#6a5acd';
            ctx.beginPath();
            ctx.arc(yInterceptPixelX, yInterceptPixelY, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 重置视图
        function resetView() {
            scale = 40;
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            drawGraph();
        }
        
        // 重置函数
        function resetFunction() {
            aSlider.value = 1;
            aInput.value = 1;
            bSlider.value = 0;
            bInput.value = 0;
            cSlider.value = 0;
            cInput.value = 0;
            
            updateFunction();
            drawGraph();
        }
        
        // 生成随机函数
        function generateRandomFunction() {
            let a, b, c;
            
            if (integerMode.checked) {
                // 整数模式：生成整数
                a = Math.floor(Math.random() * 9) - 4; // -4 到 4
                b = Math.floor(Math.random() * 21) - 10; // -10 到 10
                c = Math.floor(Math.random() * 21) - 10; // -10 到 10
                
                // 确保a不为0
                if (a === 0) a = 1;
            } else {
                // 小数模式：生成小数
                a = (Math.random() * 4 - 2).toFixed(1);
                b = (Math.random() * 8 - 4).toFixed(1);
                c = (Math.random() * 8 - 4).toFixed(1);
            }
            
            aSlider.value = a;
            aInput.value = a;
            bSlider.value = b;
            bInput.value = b;
            cSlider.value = c;
            cInput.value = c;
            
            updateFunction();
            drawGraph();
        }
        
        // 保存图片
        function saveImage() {
            const link = document.createElement('a');
            link.download = '二次函数图像.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            // 显示保存通知
            saveNotification.classList.add('show');
            setTimeout(() => {
                saveNotification.classList.remove('show');
            }, 3000);
        }
        
        // 拖拽功能
        function startDrag(e) {
            isDragging = true;
            lastX = e.clientX || e.touches[0].clientX;
            lastY = e.clientY || e.touches[0].clientY;
            canvas.style.cursor = 'grabbing';
        }
        
        function drag(e) {
            if (!isDragging) return;
            
            e.preventDefault();
            
            const currentX = e.clientX || e.touches[0].clientX;
            const currentY = e.clientY || e.touches[0].clientY;
            
            const deltaX = currentX - lastX;
            const deltaY = currentY - lastY;
            
            offsetX += deltaX;
            offsetY += deltaY;
            
            lastX = currentX;
            lastY = currentY;
            
            drawGraph();
        }
        
        function endDrag() {
            isDragging = false;
            canvas.style.cursor = 'default';
        }
        
        // 面板最小化/最大化
        function toggleMinimize(panel, button) {
            panel.classList.toggle('panel-minimized');
            if (panel.classList.contains('panel-minimized')) {
                button.textContent = '+';
            } else {
                button.textContent = '−';
            }
        }
        
        // 触摸事件处理
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                startDrag(e);
            }
        }
        
        function handleTouchMove(e) {
            if (e.touches.length === 1) {
                drag(e);
            }
        }
        
        function handleTouchEnd() {
            endDrag();
        }
        
        // 滚轮缩放
        function handleWheel(e) {
            e.preventDefault();
            
            const zoomIntensity = 0.1;
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoom = Math.exp(wheel * zoomIntensity);
            
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;
            
            const worldX = (mouseX - offsetX) / scale;
            const worldY = (offsetY - mouseY) / scale;
            
            scale *= zoom;
            
            offsetX = mouseX - worldX * scale;
            offsetY = mouseY + worldY * scale;
            
            drawGraph();
        }
        
        // 初始化应用
        window.onload = init;
    </script>
</body>
</html>